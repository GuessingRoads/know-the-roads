<!DOCTYPE html>
<html>
<head>
  <title>Know The Roads</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <style>
    #map { height: 100vh; }

    .legend {
      background: white;
      padding: 6px 10px;
      border-radius: 4px;
      font-size: 12px;
      line-height: 1.5em;
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 1000;
    }

    #login-btn, #logout-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      padding: 8px 12px;
      background: black;
      color: white;
      border: none;
      border-radius: 4px;
      font-size: 13px;
      cursor: pointer;
      z-index: 1001;
    }

    #logout-btn { right: 130px; }

    #music-btn {
      position: absolute;
      top: 10px;
      left: 10px;
      background: white;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      font-size: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 1002;
    }

    #music-modal {
      position: absolute;
      top: 50px;
      left: 10px;
      background: white;
      border: 1px solid #ccc;
      padding: 8px;
      border-radius: 6px;
      z-index: 1003;
      display: flex;
      flex-direction: column;
      align-items: stretch;
    }

    #music-modal button {
      margin-top: 4px;
      min-width: 85px;
      padding: 5px 12px;
      font-size: 13px;
      border-radius: 4px;
      border: 1px solid #888;
      background: #f8f8f8;
      cursor: pointer;
      text-align: center;
      box-sizing: border-box;
    }

    #guess-modal {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      padding: 16px;
      border-radius: 8px;
      border: 2px solid #333;
      box-shadow: 0 4px 10px rgba(0,0,0,0.2);
      z-index: 1005;
      display: none;
      width: 260px;
      text-align: center;
    }

    #guess-modal input {
      width: 100%;
      padding: 8px;
      margin-bottom: 8px;
      font-size: 16px;
    }

    #guess-modal button {
      padding: 6px 12px;
      font-size: 14px;
      border-radius: 4px;
      border: none;
      background-color: #333;
      color: white;
      cursor: pointer;
      margin: 4px;
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="music-btn" title="Music Settings">🎵</div>
  <div id="music-modal">
    <button id="mute-btn">Mute</button>
    <button id="skip-btn">Skip Track</button>
  </div>
  <div class="legend" id="legend">
    <strong>Legend</strong><br>
    Black: Unguessed<br>
    Red: Incorrect<br>
    Orange: Hint Used<br>
    Gray: Correct<br>
    Yellow: Suffix Warning<br>
    Prismatic: Ultra-Hard Mode
  </div>
  <button id="login-btn">Login with Google</button>
  <button id="logout-btn">Logout</button>

  <div id="guess-modal">
    <input type="text" id="guess-input" placeholder="Enter road name" />
    <div>
      <button id="submit-guess">Submit</button>
      <button id="give-up">Give Up</button>
    </div>
    <div id="feedback-message" style="margin-top: 8px; font-size: 14px;"></div>
  </div>

 <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script type="module">
  let currentRoad = null;
  import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm'
  
  const supabase = createClient(
    'https://yulvzmznvnctgaiwuypb.supabase.co',
    'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inl1bHZ6bXpudm5jdGdhaXd1eXBiIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTIyNzEzNjMsImV4cCI6MjA2Nzg0NzM2M30.7LOh2rqTkdB4oNJuFTd5o9snzX9dA7AOkmt7y9prQgM'
  );

  import { roadNameToIds } from './roadNameToIds.js';
  console.log("Loaded roadNameToIds:", Object.keys(roadNameToIds));
  const map = L.map('map', { zoomControl: false }).setView([40.09, -76.3], 12);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 19
}).addTo(map);

const suffixMap = {
  st: 'street',
  ave: 'avenue',
  rd: 'road',
  blvd: 'boulevard',
  ln: 'lane',
  dr: 'drive',
  ct: 'court',
  cir: 'circle',
  hwy: 'highway',
  pkwy: 'parkway',
  ter: 'terrace',
  pl: 'place'
};

let nameToLayers = {};
let guessedSegmentIds = new Set();
let attemptCounts = {};  // Track attempts per segment ID
let currentUserId = null;
  const roadAttemptsMap = new Map(); // Tracks attempts per road name
  const completedRoads = new Set(); // Tracks roads finalized via correct guess or 4th attempt
let segmentStateMap = new Map();
  const segmentIdToName = {};


document.getElementById('login-btn').onclick = async () => {
  const { error } = await supabase.auth.signInWithOAuth({
    provider: 'google',
    options: { redirectTo: window.location.origin }
  });
  if (error) alert('Login error: ' + error.message);
};

document.getElementById('logout-btn').onclick = async () => {
  const { error } = await supabase.auth.signOut();
  if (error) alert('Logout error: ' + error.message);
  else location.reload();
};

supabase.auth.onAuthStateChange((event, session) => {
  console.log("Auth event:", event, "Session:", session);
});

async function checkLogin() {
  const { data: { session } } = await supabase.auth.getSession();
  const user = session?.user;
  if (user) {
    currentUserId = user.id;
    await loadGuessedSegmentIds();
  }
}

async function loadGuessedSegmentIds() {
  const { data, error } = await supabase
    .from('road_guesses')
    .select('road_id, correct, used_hint')
    .eq('user_id', currentUserId);

  if (error) {
    console.error('❌ Error loading guesses:', error);
    return;
  }

  guessedSegmentIds.clear();
  segmentStateMap.clear();

  data.forEach(row => {
    guessedSegmentIds.add(row.road_id);
    segmentStateMap.set(row.road_id, {
      correct: row.correct,
      used_hint: row.used_hint
    });
  });
}

 async function saveGuessSegmentIds(segmentIds, isCorrect, usedHint = false) {
  for (const id of segmentIds) {
    const stringId = String(id);
    let normalized;

    if (stringId.startsWith('way/')) {
      const rawName = segmentIdToName[stringId] || "";
      normalized = normalizeName(rawName);
    } else {
      normalized = normalizeName(stringId);
    }

    console.log("🔗 Matched segment IDs for road:", normalized, "→", stringId);
    
    const existing = segmentStateMap.get(stringId);
    console.log("🔎 Existing value for road", stringId, "→", existing);

    if (!existing) {
      console.log("📝 Inserting guess →", {
        currentUserId,
        stringId,
        normalized,
        isCorrect,
        usedHint
      });

      const { error } = await supabase.from('road_guesses').insert([{
        user_id: currentUserId,
        road_id: stringId,
        road_name: normalized,
        correct: isCorrect,
        used_hint: usedHint
      }]);

      if (error) {
        console.error("❌ Supabase insert error:", error);
        console.log("Debug values →", { currentUserId, stringId, normalized, isCorrect, usedHint });
      } else {
        guessedSegmentIds.add(stringId);
        segmentStateMap.set(stringId, { correct: isCorrect, used_hint: usedHint });
      }
    } else if (isCorrect && !existing.correct) {
      const { error } = await supabase
        .from('road_guesses')
        .update({ correct: true, used_hint: usedHint })
        .eq('user_id', currentUserId)
        .eq('road_id', stringId);
      if (!error) {
        segmentStateMap.set(stringId, { correct: true, used_hint: usedHint });
      }
    }
  }
}


function applyColorToAllSegments(name, color) {
  if (!nameToLayers[name]) return;
  for (const l of nameToLayers[name]) {
    l.setStyle({ color });
  }
}

function normalizeName(name) {
  const parts = name.trim().toLowerCase().split(" ");
  const last = parts[parts.length - 1];
  const suffix = suffixMap[last] || last;
  return [...parts.slice(0, -1), suffix].join(" ");
}

function suffixOnlyMismatch(guess, actual) {
  const g = guess.toLowerCase().split(" ");
  const a = actual.toLowerCase().split(" ");
  if (g.length !== a.length) return false;
  const sameBase = g.slice(0, -1).join(" ") === a.slice(0, -1).join(" ");
  const diffSuffix = g[g.length - 1] !== a[a.length - 1];
  return sameBase && diffSuffix;
}

async function loadMap() {
  await checkLogin();

  fetch('roads_manheim_named_only.geojson')
    .then(res => res.json())
    .then(data => {
      L.geoJSON(data, {
       onEachFeature: function (feature, layer) {
  const id = String(feature.id);
  const name = feature.properties.name || "";
         segmentIdToName[id] = name;
  if (!nameToLayers[name]) nameToLayers[name] = [];
  nameToLayers[name].push(layer);

  if (segmentStateMap.has(id)) {
    const state = segmentStateMap.get(id);
    if (!state.correct) {
      layer.setStyle({ color: 'red', weight: 6 });
    } else if (state.used_hint) {
      layer.setStyle({ color: 'orange', weight: 6 });
    } else {
      layer.setStyle({ color: 'gray', weight: 6 });
    }
  } else {
    layer.setStyle({ color: 'black', weight: 6 });
  }

  layer.on('click', function () {
  const state = segmentStateMap.get(id);
if (state?.correct || state?.used_hint) return;


    currentRoad = {
      name: name,
      id: id,
      attempts: 0,
      layer: layer
    };

    document.getElementById('guess-modal').style.display = 'block';
    document.getElementById('guess-input').value = '';
    document.getElementById('feedback-message').innerText = '';
    document.getElementById('guess-input').focus();
  });
}
                 }).addTo(map); // ✅ end of geoJSON block
      }); // ✅ closes .then(data => { ... })
} // ✅ closes loadMap()

loadMap(); // ✅ called after it's defined

// ✅ Submit handler defined OUTSIDE of loadMap
document.getElementById('submit-guess').onclick = async function () {
  if (!currentRoad) return;

  const userGuess = document.getElementById('guess-input').value.trim();
  const correctName = currentRoad.name.trim();
  const normalizedGuess = normalizeName(userGuess);
  const normalizedCorrect = normalizeName(correctName);

  let isCorrect = normalizedGuess === normalizedCorrect;
  let usedHint = false;
  let color = 'gray';

  // Wrong suffix case
  if (!isCorrect && normalizedGuess.split(' ')[0] === normalizedCorrect.split(' ')[0]) {
    color = 'yellow';
    document.getElementById('feedback-message').innerText = 'Check the suffix!';
    setTimeout(() => document.getElementById('feedback-message').innerText = '', 5000);
    const key = Object.keys(nameToLayers).find(k => normalizeName(k) === normalizedCorrect);
    for (const layer of nameToLayers[key] || []) {
      layer.setStyle({ color: 'yellow', weight: 6 });
    }
    return; // Don't count this as an attempt, and don't save to Supabase
  }

// Track attempts globally by segment ID
if (!attemptCounts[currentRoad.id]) {
  attemptCounts[currentRoad.id] = 1;
} else {
  attemptCounts[currentRoad.id] += 1;
}

// If 4th attempt or more, trigger hint
if (attemptCounts[currentRoad.id] >= 4 && !currentRoad.hintGiven) {
  currentRoad.hintGiven = true;
  const firstLetter = correctName.charAt(0).toUpperCase();
  document.getElementById('feedback-message').innerText = `Hint: Road begins with '${firstLetter}'`;
  return; // Wait for next guess
}



  // If hint was given, flag it
  if (currentRoad.hintGiven) {
    usedHint = true;
    color = 'orange';
  } else if (!isCorrect) {
    color = 'red';
  }

  // Color the correct road segments
  const normalizedKey = Object.keys(roadNameToIds).find(
    k => normalizeName(k) === normalizedCorrect
  );
  const segmentIds = roadNameToIds[normalizedKey];
  for (const layer of nameToLayers[normalizedKey] || []) {
    layer.setStyle({ color: color, weight: 6 });
  }

  await saveGuessSegmentIds(segmentIds, isCorrect, usedHint);

  // Show correct answer if hint was used but still wrong
  if (usedHint && !isCorrect) {
    alert(`Correct answer: ${correctName}`);
  }

  // Show feedback
  document.getElementById('feedback-message').innerText = isCorrect ? 'Correct!' : 'Incorrect';

  // Delay hide based on color
  let hideDelay = 800;
  if (color === 'yellow') hideDelay = 5000;

  setTimeout(() => {
    document.getElementById('guess-modal').style.display = 'none';
    document.getElementById('feedback-message').innerText = '';
    currentRoad = null;
  }, hideDelay);
};
document.getElementById('give-up').onclick = async function () {
  if (!currentRoad) return;

  const correctName = currentRoad.name.trim();
  const normalizedCorrect = normalizeName(correctName);
  const normalizedKey = Object.keys(roadNameToIds).find(
    k => normalizeName(k) === normalizedCorrect
  );
  const segmentIds = roadNameToIds[normalizedKey];

  // Update attempts
  const prevAttempts = roadAttemptsMap.get(normalizedCorrect) || 0;
  const newAttempts = prevAttempts + 1;
  roadAttemptsMap.set(normalizedCorrect, newAttempts);

  if (newAttempts >= 4) {
    // Final attempt → reveal + mark as hint-used
    for (const layer of nameToLayers[normalizedKey] || []) {
      layer.setStyle({ color: 'orange', weight: 6 });
    }
    await saveGuessSegmentIds(segmentIds, false, true); // incorrect + used hint
    alert(`Correct answer: ${correctName}`);
    document.getElementById('guess-modal').style.display = 'none';
    document.getElementById('feedback-message').innerText = '';
    currentRoad = null;
    return;
  }

  // Otherwise: regular incorrect (red), still clickable
  for (const layer of nameToLayers[normalizedKey] || []) {
    layer.setStyle({ color: 'red', weight: 6 });
  }

  await saveGuessSegmentIds(segmentIds, false, false); // incorrect no hint
  document.getElementById('guess-modal').style.display = 'none';
  document.getElementById('feedback-message').innerText = '';
  // DO NOT null currentRoad so it's still guessable
};

loadMap();

  document.getElementById('guess-input').addEventListener('keypress', function (e) {
  if (e.key === 'Enter') {
    document.getElementById('submit-guess').click();
  }
});




// 🎵 Web Audio API Seamless Loop Logic
let audioContext = null;
let sourceNode = null;
let musicBuffer = null;
let musicPlaying = false;
let isMuted = false;

const musicBtn = document.getElementById('music-btn');
const modal = document.getElementById('music-modal');
const muteBtn = document.getElementById('mute-btn');
const skipBtn = document.getElementById('skip-btn');

// Load audio buffer
async function loadMusic() {
  audioContext = new (window.AudioContext || window.webkitAudioContext)();
  const response = await fetch('music/Lofi_1.wav');
  const arrayBuffer = await response.arrayBuffer();
  musicBuffer = await audioContext.decodeAudioData(arrayBuffer);
}

// Start playing loop
function playLoop() {
  if (!musicBuffer || isMuted) return;
  sourceNode = audioContext.createBufferSource();
  sourceNode.buffer = musicBuffer;
  sourceNode.connect(audioContext.destination);
  sourceNode.loop = true;
  sourceNode.start(0);
}

// Stop loop
function stopLoop() {
  if (sourceNode) {
    sourceNode.stop(0);
    sourceNode.disconnect();
    sourceNode = null;
  }
}

musicBtn.onclick = () => {
  modal.style.display = modal.style.display === 'block' ? 'none' : 'block';
};

muteBtn.onclick = () => {
  isMuted = !isMuted;
  muteBtn.innerText = isMuted ? 'Unmute' : 'Mute';
  if (isMuted) stopLoop();
  else playLoop();
};

skipBtn.onclick = () => {
  stopLoop();
  playLoop();
};

// Start audio on first interaction
window.addEventListener('click', async () => {
  if (!musicPlaying) {
    await loadMusic();
    playLoop();
    musicPlaying = true;
  }
}, { once: true });
  </script>
</body>
</html>
