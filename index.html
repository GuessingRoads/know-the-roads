<!DOCTYPE html>
<html>
<head>

  <title>Know The Roads</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <style>
    #map { height: 100vh; }

    .legend {
  position: absolute;
  top: 10px;
  left: 10px;
  background: white;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 8px;
  font-family: system-ui, sans-serif;
  font-size: 13px;
  font-weight: 600;
  line-height: 1.4em;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.12);
  z-index: 1000;
  width: fit-content;
  max-width: 200px;
}


.legend-item {
  display: flex;
  align-items: center;
  gap: 6px;
  margin: 2px 0;
}

.legend-color {
  width: 14px;
  height: 14px;
  border-radius: 3px;
  margin-right: 8px;
  border: 1px solid #666;
  display: inline-block;
  vertical-align: middle;
  box-sizing: border-box; /* ✅ forces equal sizing and alignment */
}


    #auth-box {
  position: absolute;
  top: 10px;
  right: 10px;
  z-index: 1000;
  max-width: 220px;
  text-align: right;
}

#auth-box button {
  padding: 5px 10px;
  font-size: 12.5px;
  background: #333;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}


 #legend-buttons-wrapper {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 8px;
}


#music-btn {
  background: white;
  border-radius: 50%;
  width: 30px;
  height: 30px;
  font-size: 18px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  box-shadow: 0 2px 5px rgba(0,0,0,0.12);
  flex-shrink: 0; /* prevent stretching */
  flex-grow: 0;   /* prevent expansion */
}

#exit-zone-btn {
  padding: 6px 12px;
  font-size: 13px;
  font-family: system-ui, sans-serif;
  font-weight: 600;
  background: white;
  border: 1px solid #aaa;
  border-radius: 5px;
  box-shadow: 0 2px 6px rgba(0,0,0,0.2);
  cursor: pointer;
  flex-shrink: 0; /* prevent stretching */
  flex-grow: 0;   /* prevent expansion */
}
#legend-button-zone {
  position: absolute;
  top: calc(10px + 155px); /* adjust to be just beneath the legend */
  left: 50%;
  transform: translateX(-50%);
  z-index: 1000;
}

   
    #music-modal {
  position: absolute;
  top: 190px;
  top: 210px;
  left: 10px;
  background: white;
  border: 1px solid #ccc;
  padding: 8px;
  border-radius: 6px;
  z-index: 1003;
  flex-direction: column;
  align-items: stretch;
  opacity: 0;
  transform: translateY(-10px);
  pointer-events: none;
  transition: opacity 0.25s ease, transform 0.25s ease;
}
#music-modal.show {
  opacity: 1;
  transform: translateY(0);
  pointer-events: auto;
  display: flex;
}


    #music-modal button {
      margin-top: 4px;
      min-width: 85px;
      padding: 5px 12px;
      font-size: 13px;
      border-radius: 4px;
      border: 1px solid #888;
      background: #f8f8f8;
      cursor: pointer;
      text-align: center;
      box-sizing: border-box;
    }

    #guess-modal {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      padding: 16px;
      border-radius: 8px;
      border: 2px solid #333;
      box-shadow: 0 4px 10px rgba(0,0,0,0.2);
      z-index: 1005;
      display: none;
      width: 260px;
      text-align: center;
    }

   #guess-modal input {
  display: block;
  width: calc(100% - 16px); /* prevents overflow */
  margin: 0 auto 8px auto;
  padding: 8px;
  font-size: 16px;
  box-sizing: border-box;  /* crucial for padding */
  border: 1px solid #aaa;
  border-radius: 4px;
}


    #guess-modal button {
      padding: 6px 12px;
      font-size: 14px;
      border-radius: 4px;
      border: none;
      background-color: #333;
      color: white;
      cursor: pointer;
      margin: 4px;
    }
    #custom-tooltip {
  position: absolute;
  background-color: white;
  color: black;
  font-size: 14px;
  font-weight: bold;
  border-radius: 4px;
  padding: 2px 6px;
  box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.2);
  pointer-events: none;
  white-space: nowrap;
  z-index: 1000;
  transform: translate(-50%, -50%);
  display: none; /* Hidden by default */
}
.hover-green {
  filter: drop-shadow(0 0 6px rgba(0, 255, 0, 0.4));
  transition: filter 0.3s ease;
}


    .hint-dissolve {
  transition: opacity 2s ease;
  opacity: 1;
}

.correct-dissolve {
  transition: opacity 2000ms ease-out;
  opacity: 0;
}

.correct-final {
  stroke: #00ccff;               /* Start as active blue */
  stroke-width: 6;
  opacity: 1;
  animation: dissolveBlueToGreen 2.5s ease-out forwards;
  pointer-events: none;
}






@keyframes dissolveBlueToGreen {
  0% {
    stroke: #00ccff;             /* Blue */
    opacity: 1;
  }
  100% {
    stroke: #009944;             /* Final green */
    opacity: 0.7;                /* Slight transparency */
  }
}





   .hint-used-final {
  stroke: rgba(255, 120, 0, 1);
  opacity: 1;
  pointer-events: none;
}



  </style>
</head>
<body>
  <div id="auth-box" style="
  position: absolute;
  top: 10px;
  right: 10px;
  background: white;
  padding: 10px 12px;
  border-radius: 10px;
  box-shadow: 0 2px 6px rgba(0,0,0,0.2);
  font-family: system-ui, sans-serif;
  font-size: 13px;
  font-weight: 600;
  line-height: 1.4em;
  color: black;
  text-align: center;
  z-index: 1000;
">



  <div id="auth-message">Checking login...</div>
  <button id="login-btn" style="margin-top: 2px;">Login with Google</button>
 
<p id="login-note" style="
  font-size: 12px;
  color: #888;
  margin-top: 2px;
  margin-bottom: 2px;
  max-width: 135px;
  line-height: 1.4;
  word-wrap: break-word;
">
  🔒 You'll briefly see <code>supabase.co</code> during login, it's safe and secure.
</p>
  <button id="logout-btn" style="margin-top: 6px; display: none;">Logout</button>
</div>
  <div id="map"></div>

 <div class="legend" id="legend">
  <strong style="display: block; text-align: center; margin-bottom: 6px;">Legend</strong>
  <div class="legend-item">
  <div class="legend-color" style="background: black;"></div>
  <div style="flex: 1; text-align: center;">Unguessed</div>
</div>
  <div class="legend-item">
  <div class="legend-color" style="background: red;"></div>
  <div style="flex: 1; text-align: center;">Incorrect</div>
</div>
  <div class="legend-item">
  <div class="legend-color" style="background: orange;"></div>
  <div style="flex: 1; text-align: center;">Hint Used</div>
</div>

  <div class="legend-item">
  <div class="legend-color" style="background-color: #008000; margin-right: 15px;"></div>
  <div style="flex: 1; text-align: center;">Correct</div>
</div>


  <div class="legend-item">
  <div class="legend-color" style="background: yellow;"></div>
  <div style="flex: 1; text-align: center;">Suffix Warning</div>
</div>

  <div class="legend-item">
  <div class="legend-color" style="
    background: linear-gradient(45deg, red, orange, yellow, green, blue, indigo, violet);
    border: none;
  "></div>
  <div style="flex: 1; text-align: center;">Photo Only</div>
</div>
 <div id="legend-button-zone">
  <div id="legend-buttons-wrapper">
    <div id="music-btn" title="Music Settings">🎵</div>
    <button id="exit-zone-btn" style="display: none;">
      <span style="font-size: 16px;">⬅</span>
      <span style="font-size: 15px; font-weight: 600; margin-left: 6px;">Exit</span>
    </button>
    <button id="back-township-btn" style="display: none;">
  <span style="font-size: 16px;">⬅</span>
  <span style="font-size: 15px; font-weight: 600; margin-left: 6px;">Back (Township)</span>
</button>

<button id="back-county-btn" style="display: none;">
  <span style="font-size: 16px;">⬅</span>
  <span style="font-size: 15px; font-weight: 600; margin-left: 6px;">Back (County)</span>
</button>
  </div>
</div>
   <div id="music-modal">
    <button id="mute-btn">Mute</button>
    <button id="skip-btn">Skip Track</button>
  </div>
</div>


  <div id="guess-modal">
   <input 
  type="text" 
  id="guess-input" 
  placeholder="Enter road name" 
  autocorrect="off" 
  autocapitalize="off" 
  spellcheck="false" 
/>
<div id="inline-encouragement" style="display: none; margin-top: 10px; font-size: 12.5px; color: #333; background: #fff8dc; padding: 8px 10px; border-radius: 6px; border: 1px solid #ccc;">
  <strong>Log in to save your progress!</strong><br>
  <span style="font-size: 12px;">Guesses won’t be saved unless you log in.</span>
</div>

<p id="hint-info" style="font-size: 12.5px; color: #666; margin: 6px 0 12px; text-align: center;">
  Need help? A hint appears automatically after 4 incorrect guesses.
</p>

    <div>
      <button id="submit-guess">Submit</button>
      <button id="give-up">Give Up</button>
    </div>
    <div id="feedback-message" style="margin-top: 8px; font-size: 14px;"></div>
  </div>
  <div id="custom-tooltip">Lancaster County</div>


 <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script type="module">
  let currentRoad = null;
  let currentLayerDepth = 0; // 1 = county, 2 = township, 3 = roads
  let activeRoadName = null;
  let hoverOverlay = null;
  let worldMask;
  let roadsLayerGroup = L.layerGroup(); // Holds all road layers
  let insideLancaster = false;
  let insideManheim = false;
  // ==== Back-nav refs (safe placeholders) ====
let countyLayerRef = null;    // L.GeoJSON of the county boundary layer
let townshipLayerRef = null;  // L.Layer for the active township polygon
let countyFeatureRef = null;  // GeoJSON Feature for county (for mask)
let townshipFeatureRef = null; // GeoJSON Feature for township (for mask)



  import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm'

  const supabase = createClient(
    'https://yulvzmznvnctgaiwuypb.supabase.co',
    'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inl1bHZ6bXpudm5jdGdhaXd1eXBiIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTIyNzEzNjMsImV4cCI6MjA2Nzg0NzM2M30.7LOh2rqTkdB4oNJuFTd5o9snzX9dA7AOkmt7y9prQgM'
  );

  import { roadNameToIds } from './Conversions/Convert_Lancaster_ManheimTownship.js';
  console.log("Loaded roadNameToIds:", Object.keys(roadNameToIds));
  const map = L.map('map', { zoomControl: false }).setView([40.09, -76.3], 10);
  map.createPane('clickable-buffer');
  map.getPane('clickable-buffer').style.pointerEvents = 'auto';
  map.createPane('hiddenRoads');
  map.getPane('hiddenRoads').style.pointerEvents = 'none'; // Roads cannot block clicks initially
  map.getPane('clickable-buffer').style.opacity = '1';
  map.createPane('countyPolygon');
  map.getPane('countyPolygon').style.zIndex = 650; // higher than roads (default is 400 or 600)
  map.createPane('townshipPane');
  map.getPane('townshipPane').style.zIndex = 510;
  map.createPane('hoverPane');
  map.getPane('hoverPane').style.zIndex = 499;
  map.createPane('maskPane'); // Create a custom pane for the gray mask
  map.getPane('maskPane').style.zIndex = 299; // Ensure it renders below roads
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 19
}).addTo(map);

const suffixMap = {
  st: 'street',
  ave: 'avenue',
  rd: 'road',
  blvd: 'boulevard',
  ln: 'lane',
  dr: 'drive',
  ct: 'court',
  cir: 'circle',
  hwy: 'highway',
  pkwy: 'parkway',
  ter: 'terrace',
  pl: 'place',
  pk: 'pike'
};

let preLoginGuesses = [];
let nameToLayers = {};
let guessedSegmentIds = new Set();
let attemptCounts = {};  // Track attempts per segment ID
let currentUserId = null;
  const roadAttemptsMap = new Map(); // Tracks attempts per road name
  const completedRoads = new Set(); // Tracks roads finalized via correct guess or 4th attempt
let segmentStateMap = new Map();
  const segmentIdToName = {};
  function getPreLoginGuesses() {
  const stored = localStorage.getItem('preLoginGuesses');
  return stored ? JSON.parse(stored) : [];
}

function savePreLoginGuess(guess) {
  const guesses = getPreLoginGuesses();
  guesses.push(guess);
  localStorage.setItem('preLoginGuesses', JSON.stringify(guesses));
}

function clearPreLoginGuesses() {
  localStorage.removeItem('preLoginGuesses');
}

const loginBtn = document.getElementById('login-btn');
const logoutBtn = document.getElementById('logout-btn');
const authMessage = document.getElementById('auth-message');

loginBtn.onclick = async () => {
  const { error } = await supabase.auth.signInWithOAuth({
    provider: 'google',
  });
  if (error) alert('Login error: ' + error.message);
};

logoutBtn.onclick = async () => {
  const { error } = await supabase.auth.signOut();
  if (error) alert('Logout error: ' + error.message);
  else location.reload();
};

supabase.auth.onAuthStateChange((event, session) => {
  updateAuthUI(session?.user);

  const loginNote = document.getElementById('login-note');
  if (!loginNote) return;

  if (event === 'SIGNED_IN') {
    loginNote.style.display = 'none';
  } else if (event === 'SIGNED_OUT') {
    loginNote.style.display = 'block';
  }
});
function animateIncorrectSegments(segments, delay = 60) {
  segments.forEach((layer, index) => {
    layer._originalColor = 'red';
    setTimeout(() => {
      layer.setStyle({
  color: 'red',
  weight: 6,
  pane: 'clickable-buffer'
});
    }, index * delay);
  });
}


async function checkLogin() {
  const { data: { session } } = await supabase.auth.getSession();
  const loginNote = document.getElementById('login-note');
if (loginNote) {
  loginNote.style.display = session ? 'none' : 'block';
}
  const user = session?.user;
  if (user) {
  currentUserId = user.id;

 // Submit any saved pre-login guesses from localStorage
  const savedGuesses = getPreLoginGuesses();
  for (const guess of savedGuesses) {
    try {
      console.log('⚡ Auto-submitting pre-login guess:', guess.segmentIds);
      await saveGuessSegmentIds(guess.segmentIds, guess.isCorrect, guess.usedHint);
    } catch (error) {
      console.error('❌ Failed to submit pre-login guess:', guess, error);
    }
  }
  clearPreLoginGuesses();

  await loadGuessedSegmentIds();
}

  updateAuthUI(user);
}

function updateAuthUI(user) {
  if (user) {
    const name = user.user_metadata?.full_name?.split(' ')[0] || 'User';
    authMessage.innerText = `Hello, ${name}`;
    loginBtn.style.display = 'none';
    logoutBtn.style.display = 'inline-block';
  } else {
    authMessage.innerText = `You're not logged in.`;
    loginBtn.style.display = 'inline-block';
    logoutBtn.style.display = 'none';
  }
}


async function loadGuessedSegmentIds() {
  const { data, error } = await supabase
    .from('road_guesses')
    .select('road_id, correct, used_hint')
    .eq('user_id', currentUserId);

  if (error) {
    console.error('❌ Error loading guesses:', error);
    return;
  }

  guessedSegmentIds.clear();
  segmentStateMap.clear();

  data.forEach(row => {
    guessedSegmentIds.add(row.road_id);
    segmentStateMap.set(row.road_id, {
      correct: row.correct,
      used_hint: row.used_hint
    });
  });
}

async function saveGuessSegmentIds(segmentIds, isCorrect, usedHint = false) {
  for (const id of segmentIds) {
    const stringId = String(id);
    let normalized;

    if (stringId.startsWith('way/')) {
      const rawName = segmentIdToName[stringId] || "";
      normalized = normalizeName(rawName);
    } else {
      normalized = normalizeName(stringId);
    }

    console.log("🔗 Handling segment:", { stringId, normalized, isCorrect, usedHint });

    // Check for existing row in Supabase
    const { data: existingRows, error: fetchError } = await supabase
      .from('road_guesses')
      .select('*')
      .eq('user_id', currentUserId)
      .eq('road_id', stringId);

    if (fetchError) {
      console.error("❌ Fetch error during saveGuessSegmentIds:", fetchError);
      continue;
    }

    const existing = existingRows[0];

    // CASE 1: No existing row → INSERT
    if (!existing) {
      console.log("🆕 No existing guess found. Inserting new row:", {
        user_id: currentUserId,
        road_id: stringId,
        road_name: normalized,
        correct: isCorrect,
        used_hint: usedHint
      });

      const { error: insertError } = await supabase.from('road_guesses').upsert([{
  user_id: currentUserId,
  road_id: stringId,
  road_name: normalized,
  correct: isCorrect,
  used_hint: usedHint
}], {
  onConflict: 'user_id,road_id'
});


      if (insertError) {
        console.error("❌ Supabase insert error:", insertError);
      } else {
        segmentStateMap.set(stringId, { correct: isCorrect, used_hint: usedHint });
      }

    } else {
      // CASE 2: Row exists → may need UPDATE
      const needsUpdate =
        (isCorrect && !existing.correct) ||
        (usedHint && !existing.used_hint);

      if (needsUpdate) {
        const updates = {
          correct: isCorrect || existing.correct,
          used_hint: usedHint || existing.used_hint
        };

        console.log("✏️ Updating existing guess:", {
          user_id: currentUserId,
          road_id: stringId,
          updates
        });

        const { error: updateError } = await supabase
          .from('road_guesses')
          .update(updates)
          .eq('user_id', currentUserId)
          .eq('road_id', stringId);

        if (updateError) {
          console.error("❌ Supabase update error:", updateError);
        } else {
          segmentStateMap.set(stringId, updates);
        }
      } else {
        console.log("✅ No update needed. Existing values already match.");
      }
    }
  }
}


function applyColorToAllSegments(name, color) {
  if (!nameToLayers[name]) return;
  for (const l of nameToLayers[name]) {
    l.setStyle({ color });
  }
}

function normalizeName(name) {
  const parts = name.trim().toLowerCase().split(" ");
  const last = parts[parts.length - 1];
  const suffix = suffixMap[last] || last;
  return [...parts.slice(0, -1), suffix].join(" ");
}

function suffixOnlyMismatch(guess, actual) {
  const g = guess.toLowerCase().split(" ");
  const a = actual.toLowerCase().split(" ");
  if (g.length !== a.length) return false;
  const sameBase = g.slice(0, -1).join(" ") === a.slice(0, -1).join(" ");
  const diffSuffix = g[g.length - 1] !== a[a.length - 1];
  return sameBase && diffSuffix;
}

async function loadMap() {
  await checkLogin();

  fetch('Roads/Roads_ManheimTownship_Lancaster_PA.geojson')
    .then(res => res.json())
    .then(data => {
      const roadLayer = L.geoJSON(data, {
        // ✅ This applies to all roads, unless overridden below
          style: {
            pane: 'hiddenRoads'
          },

        onEachFeature: function (feature, layer) {
          const id = String(feature.id);
          const name = feature.properties.name || "";
          segmentIdToName[id] = name;
          if (!nameToLayers[name]) nameToLayers[name] = [];
          nameToLayers[name].push(layer);
          layer.options.pane = 'hiddenRoads'; // ✅ Force pane at layer level

          // ⬛ Style visible road based on state
          if (segmentStateMap.has(id)) {
            const state = segmentStateMap.get(id);

            if (state.used_hint) {
              layer.setStyle({
                color: 'rgba(255, 165, 0, 0.4)',
                weight: 6,
                opacity: 0.7,
                pane: 'hiddenRoads'
              });
              setTimeout(() => {
                if (layer._path) {
                  layer._path.style.opacity = '';
                  layer._path.classList.add('hint-used-final');
                }
              }, 0);
              layer._originalColor = 'orangeish';

            } else if (state.correct) {
              layer.setStyle({
                color: '#00994466',
                weight: 6,
                pane: 'hiddenRoads'
              });
              setTimeout(() => {
                if (layer._path) {
                  layer._path.style.opacity = '';
                  layer._path.classList.add('correct-final');
                }
              }, 0);
              layer._originalColor = 'greenish';

            } else {
              layer.setStyle({
                color: 'red',
                weight: 6,
                pane: 'hiddenRoads'
              });
              layer._originalColor = 'red';
            }

          } else {
            layer.setStyle({
              color: 'black',
              weight: 6,
              pane: 'hiddenRoads'
            });
            layer._originalColor = 'black';
          }

          // 🟠 Add invisible buffer layer for easier clicking/tapping
          const buffer = L.geoJSON(feature, {
            style: {
              color: 'black',
              weight: 20,
              opacity: 0,
              pane: 'clickable-buffer'
            },
            onEachFeature: function (_, bufLayer) {
              const state = segmentStateMap.get(id);
              if (state?.correct || state?.used_hint) return;
              bufLayer.on('click', () => {
                layer.fire('click');
              });
              bufLayer.on('mouseover', () => {
                layer.fire('mouseover');
              });
              bufLayer.on('mouseout', () => {
                layer.fire('mouseout');
              });
            }
          });
          buffer.addTo(map);

          // Hover effect
          layer.on('mouseover', function () {
            if (!insideLancaster) return;
            const matchingLayers = nameToLayers[name] || [];
            if (activeRoadName === name && document.getElementById('guess-modal').style.display === 'block') return;
            // 🟢 Soft glow if already guessed correctly
const state = segmentStateMap.get(String(layer.feature.id));
if (state?.correct) {
  const el = layer.getElement();
  if (el) el.classList.add('hover-green');
  return;
}

            for (const l of matchingLayers) {
              const currentColor = l._originalColor;
              if (currentColor === 'greenish') return;
              if (['black', 'red', 'yellow'].includes(currentColor)) {
                l.setStyle({
                  color: '#ffd700',
                  weight: 8,
                  opacity: 1,
                  lineCap: 'round',
                  pane: 'hiddenRoads'
                });
              }
              l.bringToFront?.();
            }
          });

          layer.on('mouseout', function () {
            const el = layer.getElement();
if (el) el.classList.remove('hover-green');
  
            const matchingLayers = nameToLayers[name] || [];
            if (activeRoadName === name && document.getElementById('guess-modal').style.display === 'block') return;
            // 🧽 Remove green glow if present



            for (const l of matchingLayers) {
              const currentColor = l._originalColor;
              if (['black', 'red', 'yellow'].includes(currentColor)) {
                l.setStyle({
                  color: currentColor,
                  weight: 6,
                  opacity: 1,
                  lineCap: 'round',
                  pane: 'hiddenRoads'
                });
              }
            }
          });

          layer.on('click', function () {
            const id = feature.id;
            if (!insideLancaster) return;
            const state = segmentStateMap.get(id);
            if (state?.correct || state?.used_hint) return;

            if (activeRoadName && nameToLayers[activeRoadName]) {
              for (const l of nameToLayers[activeRoadName]) {
                const segmentId = String(l.feature.id);
                const s = segmentStateMap.get(segmentId);
                if (s?.correct) {
                  l._path?.classList.add('correct-final');
                } else if (s?.used_hint) {
                  l._path?.classList.add('hint-used-final');
                } else if (s?.incorrect) {
                  l.setStyle({ color: 'red', weight: 6, pane: 'clickable-buffer' });
                  l._originalColor = 'red';
                } else {
                  l.setStyle({ color: 'black', weight: 6, pane: 'clickable-buffer' });
                  l._originalColor = 'black';
                }
              }
            }

            for (const l of nameToLayers[name] || []) {
  const sid = String(l.feature.id);
  const s = segmentStateMap.get(sid);
  if (!s || (!s.correct && !s.used_hint)) {
    l.setStyle({ color: '#00ccff', weight: 8, pane: 'hiddenRoads' });
    l._originalColor = 'blue'; // Optional: update originalColor if needed
  }
}


            activeRoadName = name;
            currentRoad = { name, id, attempts: 0, layer };
            interactionCount++;

            document.getElementById('guess-modal').style.display = 'block';
            document.getElementById('guess-input').value = '';
            document.getElementById('feedback-message').innerText = '';
            document.getElementById('guess-input').focus();
          });
        }
      });

      roadsLayerGroup.addLayer(roadLayer);
      });
    };


fetch('Counties/Boundaries_County_Lancaster_PA.geojson')
  .then(res => res.json())
  .then(data => {
    const countyLayer = L.geoJSON(data, {
      style: {
        color: 'black',
        weight: 1.5,
        fillColor: '#cccccc',
        fillOpacity: 0.7,
        pane: 'countyPolygon'
      },
      onEachFeature: function (feature, layer) {
        countyFeatureRef = feature;
        layer.on('mouseover', function () {
          if (insideLancaster) return;
          const tooltip = document.getElementById('custom-tooltip');
          tooltip.innerText = 'Lancaster County';          // ✅ add this
          const center = layer.getBounds().getCenter();
          const screenPoint = map.latLngToContainerPoint(center);
          tooltip.style.left = screenPoint.x + 'px';
          tooltip.style.top = screenPoint.y + 'px';
          tooltip.style.display = 'block';
        });

        layer.on('mouseout', function () {
          const tooltip = document.getElementById('custom-tooltip');
          tooltip.style.display = 'none';
          tooltip.innerText = '';                           // ✅ add this
        });
        layer.on('click', function () {
          map.fitBounds(layer.getBounds());
          currentLayerDepth = 2;
updateBackButtonVisibility();

          insideLancaster = true;

          if (!worldMask) {
            worldMask = L.geoJSON(createWorldMask(feature), {
              style: {
                fillColor: '#cccccc',
                fillOpacity: 0.7,
                stroke: false,
                pane: 'maskPane'
              }
            }).addTo(map);

            worldMask.eachLayer(layer => {
              const el = layer.getElement();
              if (el) el.style.pointerEvents = 'none';
            });
          }

          setTimeout(() => {
            layer.setStyle({ fillOpacity: 0 });

            const path = layer._path;
            if (path) {
              path.style.outline = 'none';
              path.style.pointerEvents = 'none';
            }

            const mapContainer = map.getContainer();
            if (mapContainer) {
              mapContainer.blur();
            }

            // ✅ Load Manheim Township after zoom-in
            fetch('Townships/Boundaries_Township_ManheimTownship_PA.geojson')
              .then(r => r.json())
              .then(mtData => {
                L.geoJSON(mtData, {
                  pane: 'townshipPane',
                  style: {
                    color: 'black',
                    weight: 1.5,
                    fillColor: '#ff8800',
                    fillOpacity: 0.25
                  },
                  onEachFeature: (feature, mtLayer) => {
                    townshipLayerRef = mtLayer;
                    townshipFeatureRef = feature;
                    mtLayer.on('mouseover', function () {
  if (insideManheim) return;

  const tooltip = document.getElementById('custom-tooltip');
  const center = mtLayer.getBounds().getCenter();
  const screenPoint = map.latLngToContainerPoint(center);

  tooltip.innerText = "Manheim Township";
  tooltip.style.left = screenPoint.x + 'px';
  tooltip.style.top = screenPoint.y + 'px';
  tooltip.style.display = 'block';
});

mtLayer.on('mouseout', function () {
  const tooltip = document.getElementById('custom-tooltip');
  tooltip.style.display = 'none';
  tooltip.innerText = '';
});
mtLayer.on('mouseover', function () {
  if (insideManheim) return; // already clicked

  // 🧹 Remove old hover overlay if any
  if (hoverOverlay) {
    map.removeLayer(hoverOverlay);
    hoverOverlay = null;
  }

  // 🟡 Add gold semi-transparent hover overlay
  hoverOverlay = L.geoJSON(mtLayer.feature, {
    pane: 'hoverPane', // we'll define this pane in step 3
    style: {
      fillColor: '#ffd700',
      fillOpacity: 0.3,
      color: 'black',
      weight: 1,
      opacity: 1
    }
  }).addTo(map);

  // 🔒 Make hover overlay ignore pointer events
  hoverOverlay.eachLayer(l => {
    const el = l.getElement();
    if (el) el.style.pointerEvents = 'none';
  });
});
mtLayer.on('mouseout', function () {
  if (hoverOverlay) {
    map.removeLayer(hoverOverlay);
    hoverOverlay = null;
  }
});




                    mtLayer.on('click', () => {
 map.fitBounds(mtLayer.getBounds(), { maxZoom: 15 });
console.log("📍 Manheim Township clicked");

insideManheim = true;     // now inside a township
currentLayerDepth = 3;    // township/roads view
updateBackButtonVisibility();

mtLayer.unbindTooltip();



  // 🔒 Disable interaction and fade MT polygon
  mtLayer.setStyle({
    fillOpacity: 0,
    weight: 1.5,
    color: 'black',
    opacity: 1
  });

  const mtPath = mtLayer._path;
  if (mtPath) {
    mtPath.style.pointerEvents = 'none';
    mtPath.style.outline = 'none';
  }

  // 🧱 Create mask that reveals only MT
if (worldMask) {
  map.removeLayer(worldMask);
  worldMask = null;
}

worldMask = L.geoJSON(createWorldMask(feature), {
  style: {
    fillColor: '#cccccc',
    fillOpacity: 0.7,
    stroke: false,
    pane: 'maskPane'
  }
}).addTo(map);

worldMask.eachLayer(layer => {
  const el = layer.getElement();
  if (el) el.style.pointerEvents = 'none';
});


  // ✅ Show roads after MT is clicked
  map.addLayer(roadsLayerGroup);
});

                  }
                }).addTo(map);
              });
          }, 500);
        });
      }
    }).addTo(map);
    countyLayerRef = countyLayer; // <-- put this right here

    function createWorldMask(feature) {
      const bounds = map.getBounds().pad(1);
      const outer = [
        [bounds.getSouthWest().lng - 10, bounds.getSouthWest().lat - 10],
        [bounds.getNorthEast().lng + 10, bounds.getSouthWest().lat - 10],
        [bounds.getNorthEast().lng + 10, bounds.getNorthEast().lat + 10],
        [bounds.getSouthWest().lng - 10, bounds.getNorthEast().lat + 10],
        [bounds.getSouthWest().lng - 10, bounds.getSouthWest().lat - 10]
      ];

      let holes = [];

      if (feature.geometry.type === 'Polygon') {
        holes = feature.geometry.coordinates;
      } else if (feature.geometry.type === 'MultiPolygon') {
        holes = feature.geometry.coordinates.flat();
      }

      return {
        type: "Feature",
        geometry: {
          type: "Polygon",
          coordinates: [outer, ...holes]
        }
      };
    }
  });

loadMap();
  updateBackButtonVisibility();


  document.getElementById('guess-input').addEventListener('keypress', function (e) {
  if (e.key === 'Enter') {
    document.getElementById('submit-guess').click();
  }
});
  document.getElementById('submit-guess').addEventListener('click', () => {
  const userGuess = document.getElementById('guess-input').value.trim();
  if (!currentRoad || !currentRoad.name) return;

  const normalizedGuess = normalizeName(userGuess);
  const normalizedAnswer = normalizeName(currentRoad.name);

  if (normalizedGuess === normalizedAnswer) {
    for (const l of nameToLayers[currentRoad.name] || []) {
  const sid = String(l.feature.id);
  segmentStateMap.set(sid, { correct: true, used_hint: false });
}

    // ✅ Correct guess
    currentRoad.segments.forEach(layer => {
      layer.setStyle({ color: 'gray' });
      layer.off('click');
    });

    // Close modal
    document.getElementById('guess-modal').style.display = 'none';
    document.getElementById('guess-input').value = '';
    document.getElementById('feedback-message').innerText = '';

    // Save correct guess to Supabase
    saveGuessSegmentIds(currentRoad.name, true, false);
  } else {
    // ❌ Incorrect guess
    handleIncorrectGuess(userGuess);
  }
});

document.getElementById('guess-input').addEventListener('input', async function (e) {
  if (!currentRoad) return;

  const userGuess = e.target.value.trim();
  const correctName = currentRoad.name.trim();
  const normalizedGuess = normalizeName(userGuess);
  const normalizedCorrect = normalizeName(correctName);

  if (normalizedGuess === normalizedCorrect) {
    console.log("⚡ Auto-submitting correct guess:", userGuess);
    document.getElementById('submit-guess').click();
  }
});

document.getElementById('guess-input').addEventListener('input', () => {
  const input = document.getElementById('guess-input').value.trim();
  const normalizedInput = normalizeName(input);
  const targetName = normalizeName(currentRoad?.name || "");

  function splitNameAndSuffix(name) {
    const parts = name.trim().split(" ");
    if (parts.length === 1) return [parts[0], ""];
    const suffix = parts.pop();
    const main = parts.join(" ");
    return [main, suffix];
  }

  const [inputMain, inputSuffix] = splitNameAndSuffix(normalizedInput);
  const [targetMain, targetSuffix] = splitNameAndSuffix(targetName);

  const feedback = document.getElementById('feedback-message');

  // Only show warning if:
  // - main is correct
  // - user started typing a suffix
  // - AND the input suffix is NOT a prefix of the correct suffix
  if (
    normalizeName(inputMain) === normalizeName(targetMain) &&
    targetSuffix &&
    inputSuffix.trim() !== '' &&
    !normalizeName(targetSuffix).startsWith(normalizeName(inputSuffix))
  ) {
    feedback.innerText = 'Check suffix!';
    feedback.style.color = 'gold';
  } else {
    feedback.innerText = '';
  }
});

function updateBackButtonVisibility() {
  const exitBtn    = document.getElementById('exit-zone-btn');       // legacy/general
  const backTown   = document.getElementById('back-township-btn');   // shown at depth >= 3
  const backCounty = document.getElementById('back-county-btn');     // shown at depth == 2

  // Hide all by default
  if (exitBtn)    exitBtn.style.display = 'none';
  if (backTown)   backTown.style.display = 'none';
  if (backCounty) backCounty.style.display = 'none';

  // Depth guide used here:
  // 1 = outside county (no back button)
  // 2 = inside county (choose township) -> show County Back
  // 3+ = inside township (roads active) -> show Township Back
  if (typeof currentLayerDepth === 'number') {
    if (currentLayerDepth >= 3) {
      if (backTown) backTown.style.display = 'flex';
    } else if (currentLayerDepth === 2) {
      if (backCounty) backCounty.style.display = 'flex';
    }
  }
}
function setupBackButtons() {
  const backTown   = document.getElementById('back-township-btn');
  const backCounty = document.getElementById('back-county-btn');

  function clearHoverOverlay() {
    if (typeof hoverOverlay !== 'undefined' && hoverOverlay) {
      map.removeLayer(hoverOverlay);
      hoverOverlay = null;
    }
  }

  // 🔙 Township → County
  backTown?.addEventListener('click', () => {
    currentLayerDepth = 2;
    updateBackButtonVisibility();

    try {
      if (typeof roadsLayerGroup !== 'undefined' && map.hasLayer(roadsLayerGroup)) {
        map.removeLayer(roadsLayerGroup);
      }

      if (typeof insideManheim !== 'undefined') insideManheim = false;
      if (typeof townshipLayerRef !== 'undefined' && townshipLayerRef) {
        try {
          townshipLayerRef.setStyle({ fillOpacity: 0.25, weight: 1.5, color: 'black', opacity: 1 });
          const p = townshipLayerRef._path;
          if (p) { p.style.pointerEvents = 'auto'; p.style.outline = ''; }
        } catch {}
      }

      const tt = document.getElementById('custom-tooltip');
      if (tt) { tt.style.display = 'none'; tt.innerText = ''; }
      clearHoverOverlay();

      if (countyLayerRef) {
        const b = countyLayerRef.getBounds();
        if (b && b.isValid && b.isValid()) {
          map.flyToBounds(b, { padding: [40, 40], maxZoom: 12 });
        }
      }

      setTimeout(() => {
        if (typeof insideLancaster !== 'undefined') insideLancaster = true;

        if (!map.getPane('maskPane')) {
          map.createPane('maskPane');
          map.getPane('maskPane').style.zIndex = 200;
        }

        if (typeof worldMask !== 'undefined' && worldMask) {
          map.removeLayer(worldMask);
          worldMask = null;
        }

        let countyGeo = null;
        if (countyLayerRef && typeof countyLayerRef.toGeoJSON === 'function') {
          countyGeo = countyLayerRef.toGeoJSON();
        } else if (countyFeatureRef) {
          countyGeo = countyFeatureRef;
        }

        const countyFeature =
          countyGeo && countyGeo.type === 'FeatureCollection'
            ? countyGeo.features[0]
            : (countyGeo && countyGeo.type === 'Feature' ? countyGeo : null);

        if (countyFeature) {
          worldMask = L.geoJSON(createWorldMask(countyFeature), {
            style: { fillColor: '#cccccc', fillOpacity: 0.7, stroke: false, pane: 'maskPane' }
          }).addTo(map);

          worldMask.eachLayer(l => {
            const el = l.getElement();
            if (el) el.style.pointerEvents = 'none';
          });
        } else {
          console.warn('Back(Township): could not normalize county geometry for mask.');
        }
      }, 150);
    } catch (err) {
      console.warn('Back(Township) handler error (non-fatal):', err);
    }
  });

  // 🔙 County → Outside county (world/state)
  backCounty?.addEventListener('click', () => {
    if (typeof roadsLayerGroup !== 'undefined' && map.hasLayer(roadsLayerGroup)) {
      map.removeLayer(roadsLayerGroup);
    }
    clearHoverOverlay();

    const tt = document.getElementById('custom-tooltip');
    if (tt) { tt.style.display = 'none'; tt.innerText = ''; }

    if (typeof townshipLayerRef !== 'undefined' && townshipLayerRef && map.hasLayer(townshipLayerRef)) {
      try { map.removeLayer(townshipLayerRef); } catch {}
    }

    if (typeof insideManheim !== 'undefined') insideManheim = false;
    if (typeof insideLancaster !== 'undefined') insideLancaster = false;

    if (countyLayerRef) {
      countyLayerRef.eachLayer(l => {
        try {
          l.setStyle({ fillOpacity: 0.7 });
          const p = l._path;
          if (p) { p.style.pointerEvents = 'auto'; p.style.outline = ''; }
        } catch {}
      });
    }

    if (typeof worldMask !== 'undefined' && worldMask) {
      map.removeLayer(worldMask);
      worldMask = null;
    }
    map.setView([40.09, -76.3], 10);

    if (typeof currentLayerDepth !== 'undefined') currentLayerDepth = 1;
    updateBackButtonVisibility();
  });
} // ← CLOSES setupBackButtons()





// 🎵 Web Audio API Seamless Loop Logic
let audioContext = null;
let sourceNode = null;
let musicBuffer = null;
let musicPlaying = false;
let isMuted = false;

const musicBtn = document.getElementById('music-btn');
const modal = document.getElementById('music-modal');
const muteBtn = document.getElementById('mute-btn');
const skipBtn = document.getElementById('skip-btn');

// Load audio buffer
async function loadMusic() {
  audioContext = new (window.AudioContext || window.webkitAudioContext)();
  const response = await fetch('music/Lofi_1.wav');
  const arrayBuffer = await response.arrayBuffer();
  musicBuffer = await audioContext.decodeAudioData(arrayBuffer);
}

// Start playing loop
function playLoop() {
  if (!musicBuffer || isMuted) return;
  sourceNode = audioContext.createBufferSource();
  sourceNode.buffer = musicBuffer;
  sourceNode.connect(audioContext.destination);
  sourceNode.loop = true;
  sourceNode.start(0);

}


// Stop loop
function stopLoop() {
  if (sourceNode) {
    sourceNode.stop(0);
    sourceNode.disconnect();
    sourceNode = null;
  }
}

let musicModalVisible = false;

musicBtn.onclick = () => {
  musicModalVisible = !musicModalVisible;

  if (musicModalVisible) {
    modal.classList.add('show');
  } else {
    modal.classList.remove('show');
  }
};


muteBtn.onclick = () => {
  isMuted = !isMuted;
  muteBtn.innerText = isMuted ? 'Unmute' : 'Mute';
  if (isMuted) stopLoop();
  else playLoop();
};

skipBtn.onclick = () => {
  stopLoop();
  playLoop();
};

// Start audio on first interaction
window.addEventListener('click', async () => {
  if (!musicPlaying) {
    await loadMusic();
    playLoop();
    musicPlaying = true;
  }
}, { once: true });
  document.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'visible' && musicPlaying && !isMuted) {
    console.log("👆 Page returned to focus. Waiting for user tap to resume music...");
    const resumeHandler = async () => {
      try {
        await audioContext.resume();
        stopLoop();
        playLoop();
        console.log("✅ Music resumed after user tap.");
      } catch (e) {
        console.error("❌ Resume failed:", e);
      }
      window.removeEventListener('click', resumeHandler);
    };
    window.addEventListener('click', resumeHandler);
  }
});
let interactionCount = 0;

  function maybeShowEncouragement() {
  const session = supabase.auth.getSession();
  session.then(({ data }) => {
    if (!data.session && interactionCount === 3) {
      const inlineEnc = document.getElementById('inline-encouragement');
      if (inlineEnc) inlineEnc.style.display = 'block';
    }
  });
}
function triggerCorrectDissolveAnimation(layer) {
  const el = layer.getElement();
  if (!el) return;

  // ✅ Reset any inline styles (in case of red/yellow/orange overrides)
  el.style.transition = '';
  el.style.stroke = 'rgba(0, 160, 0, 0.4)';
  el.style.strokeDasharray = '';
  el.style.strokeDashoffset = '';
  el.style.opacity = '1';

  // ✅ Remove class if already applied (force restart)
  el.classList.remove('correct-final');
  void el.offsetWidth; // force reflow

  // ✅ Add class to trigger dissolve
  el.classList.add('correct-final');
}





// ✅ Submit handler defined OUTSIDE of loadMap
document.getElementById('submit-guess').onclick = async function () {
  if (!currentRoad) return;

  const userGuess = document.getElementById('guess-input').value.trim();
  if (!userGuess) return;

  interactionCount++;
  maybeShowEncouragement();

  const correctName = currentRoad.name.trim();
  const normalizedGuess = normalizeName(userGuess);
  const normalizedCorrect = normalizeName(correctName);

  let isCorrect = normalizedGuess === normalizedCorrect;
  let usedHint = false;
  let color = 'gray';

  // Wrong suffix case
  if (!isCorrect && normalizedGuess.split(' ')[0] === normalizedCorrect.split(' ')[0]) {
    color = 'yellow';
    document.getElementById('feedback-message').innerText = 'Check the suffix!';
    setTimeout(() => document.getElementById('feedback-message').innerText = '', 5000);
    const key = Object.keys(nameToLayers).find(k => normalizeName(k) === normalizedCorrect);
    for (const layer of nameToLayers[key] || []) {
      layer.setStyle({
  color: 'yellow',
  weight: 6,
  pane: 'clickable-buffer'
});

      layer._originalColor = 'yellow';
    }
    return; // Don't count this as an attempt, and don't save to Supabase
  }

// Track attempts globally by segment ID
if (!attemptCounts[normalizedCorrect]) {
  attemptCounts[normalizedCorrect] = 1;
} else {
  attemptCounts[normalizedCorrect] += 1;
}
console.log("🧠 attemptCounts =", attemptCounts);
console.log("📌 currentRoad.id =", currentRoad.id);
console.log("📊 attempts so far =", attemptCounts[normalizedCorrect]);

if (attemptCounts[normalizedCorrect] >= 4 && !currentRoad.hintGiven) {
  for (const l of nameToLayers[currentRoad.name] || []) {
  const sid = String(l.feature.id);
  segmentStateMap.set(sid, { correct: false, used_hint: true });
}
  currentRoad.hintGiven = true;
  const firstLetter = correctName.charAt(0).toUpperCase();
  console.log("🔥 HINT TRIGGERED");
  document.getElementById('feedback-message').innerText = `Hint: Road begins with '${firstLetter}'`;
  document.getElementById('feedback-message').style.color = 'orange';

  // Keep modal open
  document.getElementById('guess-input').value = '';
  document.getElementById('guess-input').focus();

  return;
}

  // If hint was given, flag it
  if (currentRoad.hintGiven) {
    usedHint = true;
    color = 'orange';
  } else if (!isCorrect) {
    color = 'red';
  }

  // Color the correct road segments
  const normalizedKey = Object.keys(roadNameToIds).find(
    k => normalizeName(k) === normalizedCorrect
  );
  const segmentIds = roadNameToIds[normalizedKey];
  const layers = nameToLayers[normalizedKey] || [];

if (isCorrect) {
  for (const layer of layers) {
    triggerCorrectDissolveAnimation(layer);
    layer._originalColor = 'greenish';
  }
} else if (usedHint) {
  for (const layer of layers) {
    layer.setStyle({
  color: '#FF8000',   
  weight: 7,
  opacity: 0.9,
  pane: 'hiddenRoads'
});

    layer._originalColor = '#FF8000';
  }
} else {
  // Animate incorrect red segments
  animateIncorrectSegments(layers);
}
// ✅ Mark red segments as incorrect in segmentStateMap
if (!isCorrect && !usedHint) {
  for (const id of segmentIds) {
    segmentStateMap.set(String(id), { correct: false, used_hint: false, incorrect: true });
  }
}


if (currentUserId) {
  await saveGuessSegmentIds(segmentIds, isCorrect, usedHint);
} else {
  savePreLoginGuess({ segmentIds, isCorrect, usedHint });
}

  if (isCorrect || usedHint) {
  completedRoads.add(normalizedCorrect);
}
  // Show correct answer if hint was used but still wrong
  if (usedHint && !isCorrect) {
    alert(`Correct answer: ${correctName}`);
  }

  // Show feedback
  document.getElementById('feedback-message').innerText = isCorrect ? 'Correct!' : 'Incorrect';

  // Delay hide based on color
  let hideDelay = 800;
  if (color === 'yellow') hideDelay = 5001;

  if (isCorrect || usedHint) {
  setTimeout(() => {
    document.getElementById('guess-modal').style.display = 'none';
    document.getElementById('feedback-message').innerText = '';
    currentRoad = null;
    window.scrollTo({ top: 0, behavior: 'smooth' });
  }, hideDelay);
} else {
  // 🔴 Incorrect guess — close immediately
  document.getElementById('guess-modal').style.display = 'none';
  document.getElementById('feedback-message').innerText = '';
  currentRoad = null;
  window.scrollTo({ top: 0, behavior: 'smooth' });
}

};
document.getElementById('give-up').onclick = async function () {
  if (!currentRoad) return;

  const correctName = currentRoad.name.trim();
  const normalizedCorrect = normalizeName(correctName);
  const normalizedKey = Object.keys(roadNameToIds).find(
    k => normalizeName(k) === normalizedCorrect
  );
  const segmentIds = roadNameToIds[normalizedKey];
  const layers = nameToLayers[normalizedKey] || [];

  // Track attempts
  if (!attemptCounts[normalizedCorrect]) {
    attemptCounts[normalizedCorrect] = 1;
  } else {
    attemptCounts[normalizedCorrect] += 1;
  }

  let usedHint = false;
  let isCorrect = false;

  // Show hint on 4th give-up if not already shown
  if (attemptCounts[normalizedCorrect] >= 4 && !currentRoad.hintGiven) {
    currentRoad.hintGiven = true;

    const firstLetter = correctName.charAt(0).toUpperCase();
    document.getElementById('feedback-message').innerText = `Hint: Road begins with '${firstLetter}'`;

    document.getElementById('guess-input').value = '';
    document.getElementById('guess-input').focus();

    return; // ✅ Wait for next user input
  }

  // Otherwise, mark road (red or orange based on hint state)
  usedHint = currentRoad.hintGiven;

  for (const layer of layers) {
  const style = usedHint
    ? { color: 'rgba(255, 165, 0, 0.4)', weight: 6, opacity: 0.7, pane: 'clickable-buffer' }
    : { color: 'red', weight: 6, pane: 'clickable-buffer' };

  layer.setStyle(style);
  layer._originalColor = usedHint ? 'rgba(255, 165, 0, 0.4)' : 'red';
}


  if (currentUserId) {
    await saveGuessSegmentIds(segmentIds, false, usedHint);
  } else {
    savePreLoginGuess({ segmentIds, isCorrect: false, usedHint });
  }

  for (const id of segmentIds) {
    segmentStateMap.set(String(id), {
      correct: false,
      used_hint: usedHint,
      incorrect: !usedHint
    });
  }

  document.getElementById('feedback-message').innerText =
    usedHint ? `Correct answer: ${correctName}` : 'Incorrect';
  document.getElementById('feedback-message').style.color = 'orange';


  // ✅ Close modal after short delay (2s for hint, 0s for red)
  setTimeout(() => {
    document.getElementById('guess-modal').style.display = 'none';
    document.getElementById('feedback-message').innerText = '';
    currentRoad = null;
    window.scrollTo({ top: 0, behavior: 'smooth' });
  }, usedHint ? 2000 : 0);
};
setupBackButtons();
  </script>
</body>
</html>
